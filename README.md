# Laboration 2

## Environment & Tools
Window 10 pro, git version 2.33.0.windows.2, Intellij 2022.2.1

## Purpose
The purpose of this lab is to implement the computation of the fibonacci sequence using 
the functional and the reactive programming approach and compare the two approaches together 
with an imperative approach. The implementation of the imperative approach is provided.

## Procedure
A project skeleton was provided with this lab that included a FibonacciInterface 
interface which is implemented by three classes for the three programming paradigms.
The implementation of the imperative approach is provided in the FibonacciImperative class.
The FibonacciStreamFP and FibonacciStreamRX classes for the functional and reactive paradigms 
respectively contains three unimplemented override methods to be implemented; ``fibonacciVal()``,
``fibonacciSum()`` and ``fibonacciSeqAndVal()``. A record Pair is also provide which holds two values of 
type long and two methods ``first()`` and ``second()`` that returns the first and second values respectively.

For the Reactive approach ``Observable.range()`` operator was used to create a stream of numbers whose limit 
was specified by the passed limit. The ``.scan()`` operator was then applied on the stream which takes a seed 
and a bi-function. The seed is a Pair object which contains the first two values of the fibonacci sequence 
(0,1). The bi-function takes an accumulator and a Pair object as input and returns a Pair object whose first value 
is the second value of the input pair and the second value is the sum of the first and second values of the input.
How the emissions from the ``.scan()`` operator is processed further depends on the method being implemented.
In the fibonacciVal method the fibonacci values were obtained using the ``.reduce()`` operator that append the first() values of the emissions
to a single string seperated by a comma and space, using a StringBuilder as a seed. 
The ``delete()`` method of the StringBuilder class was used to delete unwanted ", " at the beginning of the string.
In the fibonacciSum method, the ``.reduce()`` operator was also used but with seed ``0L`` and a bi-function that takes 
an accumulator and the Pair objects from the ``.scan()`` operator and return the sum of all the first values of the 
from all the emissions. In the fibonacciSeqAndVal method, the ``.zipWith()`` operator was used to zip the first value 
of each emission from the ``.scan()`` operator to an emission from another stream generated by ``Observable.range(0, limit)`` and returns a string 
made of the two values seperated by ":". The ``.reduce()`` operator was then applied to append the String emissions to 
a single string and format the string. The ``delete()`` was used to delete unwanted characters at the beginning of the string. 
All three methods printed the final value inside the .subscribe() operator. 

For the functional approach, the Stream API was used to generate the stream and pipe operators to a single stream. 
The implementations for the three functions where all done inside a ``System.out.println()`` method which prints final results.
The ``Stream.iterate()`` operator was used which takes a seed ``Pair(0,1)`` and an UnaryOperator that returns the next 
emission as a Pair whose first value is the second value of the previous value and the second value is the sum of the first 
and second value.  
The ``.limit()`` operator was used to specify the number of emissions to be generated.
This results to a stream of Pair objects were the first value of the pair is the fibonacci value. 
This stream was used in both the fibonacciVal and fibonacciSum methods. In the fibonacciVal method, the
``.map()`` operator was used to extract the first value from the Pair object and also to convert the long value to a StringBuilder object.
The ``.reduce`` operator was then used to combine the StringBuilder object stream to a single String and format the string. The ``delete()`` 
method was called on the StringBuilder to delete unwanted ", " at the beginning of the string.
In the fibonacciSum method, the ``.map()`` operator was used to extract the first value from the Pair object. 
Another ``.map()`` operator converted the long value to an int and the ``.sum()`` operator was used to sum up all the 
fibonacci values from the stream.
In the fibonacciSeqAndVal method, ``Stream.iterate()`` operator was used to generate the stream which takes as seed 
an array of three int ``int[]{0,0,1}`` and UnaryOperator. The value at index zero of the seed is the number sequence, the values at index 1 and 2 
values 1 and 2 are the first and second  fibonacci values. The unaryOperator takes the receives the array, and return 
the next array whereby the sequence at index 1 is incremented by 1, the value at index 1 is equal to the 
value at index 2 of the passed array, and the value at index 2 is the sum of the value of index 1 and 2 of the passed 
array. The ``.map()`` operator is used to extract the sequence number at index 0 and the fibonacci value at index 1 
two values are convert to a single string seperated by ":" using a StringBuilder.

## Results
The program was run for the different approaches using different limits and the following 
is an example of the time elapsed for the different approaches.

| limit   | Imperative | functional | Reactive  |
| ------- | ---------- | ---------- | --------- |
|    10   |    119ms   |     75ms   |    815ms  |
|    20   |    118ms   |     111ms  |   1152ms  |
|    30   |    95ms    |     78ms   |   707ms   |

## Discussion 
The program presented contains all the implementation state in the aim of the project and generates the expected 
fibonacci values. In this section, we will be comparing the three approaches looking at the code implementation and the 
time taken to run the program.
With regards to the code, the imperative approach describes step by step how to get the 
fibonacci values, sum and sequences: value pairs including every detail. The code is also specific to the fibonacci
implementation and can not reused in other context. The functional and reactive approach 
on the other hand uses a declarative programming model whereby it states what needs to be done by calling predefined 
functions. This is done in the implementation by creating a stream and calling operators on the stream. 
Details on how operators perform their task is abstracted away. This abstraction makes the code for the 
functional and reactive approaches more readable and reduces the level of complexity the programmer has to deal with 
compared to the imperative approach.  

Another difference that can be seen between the different approaches is that the imperative approach uses 
assignments and states, and state  changes occur as can be seen when changing the values in the array holding 
the value pair. In the functional approach and reactive approaches, 
the codes seem quite similar in this aspect in that there are no assignments and states. However, these two 
approaches differ in that the functional approach makes use of immutable data while in the reactive approach, the program is 
designed to respond to changes in the input. The effect of this difference is that in the functional approach, the 
stream is first generated and then passed to the next operator meanwhile in the reactive approach 
the numbers emitted by the Observable are consumed by the next operator as they are produced.

The approaches also differ in the ease to debug the code. The imperative approach is more difficult to debug 
compare to the other two approaches since an error can occur any where in the program especially due to state 
changes. In the functional 
and reactive paradigms the functions have no side effect and there is no change of state 
thereby limiting where the errors can occur to the value of the input and choice of operators making it easier to debug. 
The function is guaranteed to give the same output for the same input.

There is also a difference in the time taken to compute the answers for the three approaches. Looking at the values in the 
result section, it can be seen that the imperative approach is always the fastest followed very closely by the functional approach. 
The reactive approach is by far slower than the other two approaches. Looking at the characteristics of the three approaches 
I think the results makes sense. In the imperative approach the computation and appending of the results to a string 
can be done in the same loop thereby reducing the number of iterations needed in that program meanwhile in the 
functional and reactive approaches, these actions are seperated in two different functions thereby increasing the 
number of iterations needed. However, for the reactive approach, the numbers are processed as they are emitted which 
implies that the operator is called for each emission which increases the time taken to run the whole program.

In conclusion, the imperative approach has the disadvantage code complexity and less readability but presents the advantage 
of performing simultaneous actions to save time making it faster. The functional approach and reactive have the advantage of of increased 
readability, ease to debug and reduced code complexity but present the disadvantage of repeating actions in seperate 
functions that can increase time to run program. The reactive approach have the addition advantage of being able to 
respond to changes in the input but this comes with a considerable increase in time taken to run the program. However 
this program is not a typical use case of reactive programming and in the right context, the time is not an issue.



